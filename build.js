#!/usr/bin/env node

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const os = require('os');
const path = require('path');
const fs = require('fs');

const SRC_PATH = path.join(__dirname, 'src');
const DST_PATH = path.join(__dirname, 'docs');

const existsAsync = path => fs.promises.access(path).then(() => true, e => false);

if (os.platform() === 'win32') {
  console.error('ERROR: build is not supported on Win32');
  process.exit(1);
  return;
}

(async () => {
  const startTime = Date.now();
  const BUILD_VERSION = await generateVersion();

  await step(`1. cleanup output folder`, async () => {
    let cnameText = null;
    const cnamePath = path.join(DST_PATH, 'CNAME');
    if (await existsAsync(cnamePath))
      cnameText = await fs.promises.readFile(cnamePath, 'utf8');
    await fs.promises.rmdir(DST_PATH, {recursive: true});
    await fs.promises.mkdir(DST_PATH);
    if (cnameText)
      await fs.promises.writeFile(cnamePath, cnameText, 'utf8');
  });

  await step('2. generate main.js', async () => {
    const rollup = require('rollup');
    const UglifyJS = require('uglify-es');

    const bundle = await rollup.rollup({input: path.join(SRC_PATH, 'main.js')});
    const rollupResult = await bundle.generate({format: 'iife'});
    const result = UglifyJS.minify(rollupResult.output[0].code);
    if (result.error) {
      console.error('JS Minification failed: ' + result.error);
      process.exit(1);
      return;
    }

    const header = '/* THIS FILE IS GENERATED BY build.js */\n\n';
    const versionScript = `window.__WEBSITE_VERSION__ = "${BUILD_VERSION}";\n`;
    const scriptContent = header + versionScript + result.code;
    await fs.promises.writeFile(path.join(DST_PATH, 'main.js'), scriptContent, 'utf8');
  });

  await step('3. generate all.css', async () => {
    const csso = require('csso');

    const allcss = await fs.promises.readFile(path.join(SRC_PATH, 'all.css'), 'utf8');
    const regex = /@import\s+(?:url\()?(?:'([^']+)'|"([^"]+)")/gm;
    const stylePaths = [];
    let match;
    while (match = regex.exec(allcss))
      stylePaths.push(path.resolve(SRC_PATH, match[1] || match[2]));
    const styles = stylePaths.map(stylePath => fs.readFileSync(stylePath, 'utf8'));
    const styleContent = '/* THIS FILE IS GENERATED BY build.js */\n\n' + csso.minify(styles.join('\n'), {restructure: false}).css;
    fs.writeFileSync(path.join(DST_PATH, 'all.css'), styleContent, 'utf8');
  });

  await step('4. copy index.html', async () => {
    await fs.promises.copyFile(path.join(SRC_PATH, 'index.html'), path.join(DST_PATH, 'index.html'));
  });

  await step('5. generate sw.js', async () => {
    const {injectManifest} = require('workbox-build');

    const {count, size} = await injectManifest({
      swSrc: path.join(SRC_PATH, 'sw-template.js'),
      swDest: path.join(DST_PATH, 'sw.js'),
      globDirectory: DST_PATH,
      globIgnores: ['CNAME'],
      globPatterns: ['**/*']
    });
    const kbSize = Math.round(size / 1024 * 100) / 100;
    console.log(`  - sw precaches ${count} files, totaling ${kbSize} Kb.`);
  });


  const finish = Date.now();
  const seconds = Math.round((Date.now() - startTime) / 100) / 10;
  console.log(`\nBuild ${BUILD_VERSION} is done in ${seconds} seconds.`);
})();

async function step(name, callback) {
  console.time(name);
  await callback();
  console.timeEnd(name);
}

async function generateVersion() {
  // Version consists of semver and commit SHA.
  const {stdout} = await execAsync('git log -n 1 --pretty=format:%h');
  const semver = require('./package.json').version;
  return semver + '+' + stdout;
}

async function execAsync(command) {
  const {exec} = require('child_process');
  return new Promise((resolve, reject) => {
    exec(command, (err, stdout, stderr) => {
      if (err !== null)
        reject(err);
      else
        resolve({stdout, stderr});
    });
  });
}
