---
id: class-browsercontext
title: "BrowserContext"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

* extends: [EventEmitter]

BrowserContexts provide a way to operate multiple independent browser sessions.

If a page opens another page, e.g. with a `window.open` call, the popup will belong to the parent page's browser context.

Playwright allows creating "incognito" browser contexts with [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) method. "Incognito" browser contexts don't write any browsing data to disk.

```csharp
using var playwright = await Playwright.CreateAsync();
var browser = await playwright.Firefox.LaunchAsync(new() { Headless = false });
// Create a new incognito browser context
var context = await browser.NewContextAsync();
// Create a new page inside context.
var page = await context.NewPageAsync();
await page.GotoAsync("https://bing.com");
// Dispose context once it is no longer needed.
await context.CloseAsync();
```


---

## Methods

### AddCookiesAsync {#browser-context-add-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.AddCookiesAsync</x-search>

Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be obtained via [BrowserContext.CookiesAsync()](/api/class-browsercontext.mdx#browser-context-cookies).

**Usage**

```csharp
await context.AddCookiesAsync(new[] { cookie1, cookie2 });
```

**Arguments**
- `cookies` [IEnumerable]<`Cookie`><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-option-cookies"/><a href="#browser-context-add-cookies-option-cookies" class="list-anchor">#</a>
  - `Name` [string]
    
    
  - `Value` [string]
    
    
  - `Url` [string]? *(optional)*
    
    either url or domain / path are required. Optional.
  - `Domain` [string]? *(optional)*
    
    either url or domain / path are required Optional.
  - `Path` [string]? *(optional)*
    
    either url or domain / path are required Optional.
  - `Expires` [float]? *(optional)*
    
    Unix time in seconds. Optional.
  - `HttpOnly` [bool]? *(optional)*
    
    Optional.
  - `Secure` [bool]? *(optional)*
    
    Optional.
  - `SameSite` `enum SameSiteAttribute { Strict, Lax, None }?` *(optional)*
    
    Optional.
  
  Adds cookies to the browser context.
  
  For the cookie to apply to all subdomains as well, prefix domain with a dot, like this: ".example.com".

---

### AddInitScriptAsync {#browser-context-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.AddInitScriptAsync</x-search>

Adds a script which would be evaluated in one of the following scenarios:
* Whenever a page is created in the browser context or is navigated.
* Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.

The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend the JavaScript environment, e.g. to seed `Math.random`.

**Usage**

An example of overriding `Math.random` before the page loads:

```js
// preload.js
Math.random = () => 42;
```

```csharp
await context.AddInitScriptAsync(scriptPath: "preload.js");
```

:::note
The order of evaluation of multiple scripts installed via [BrowserContext.AddInitScriptAsync()](/api/class-browsercontext.mdx#browser-context-add-init-script) and [Page.AddInitScriptAsync()](/api/class-page.mdx#page-add-init-script) is not defined.
:::

**Arguments**
- `script` [string]|[string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-script"/><a href="#browser-context-add-init-script-option-script" class="list-anchor">#</a>
  
  Script to be evaluated in all pages in the browser context.

---

### Browser {#browser-context-browser}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.Browser</x-search>

Returns the browser instance of the context. If it was launched as a persistent context null gets returned.

**Usage**

```csharp
BrowserContext.Browser
```

**Returns**
- [Browser]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-browser-return"/><a href="#browser-context-browser-return" class="list-anchor">#</a>

---

### ClearCookiesAsync {#browser-context-clear-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.ClearCookiesAsync</x-search>

Clears context cookies.

**Usage**

```csharp
await BrowserContext.ClearCookiesAsync();
```

---

### ClearPermissionsAsync {#browser-context-clear-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.ClearPermissionsAsync</x-search>

Clears all permission overrides for the browser context.

**Usage**

```csharp
var context = await browser.NewContextAsync();
await context.GrantPermissionsAsync(new[] { "clipboard-read" });
// Alternatively, you can use the helper class ContextPermissions
//  to specify the permissions...
// do stuff ...
await context.ClearPermissionsAsync();
```

---

### CloseAsync {#browser-context-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.CloseAsync</x-search>

Closes the browser context. All the pages that belong to the browser context will be closed.

:::note
The default browser context cannot be closed.
:::

**Usage**

```csharp
await BrowserContext.CloseAsync();
```

---

### CookiesAsync {#browser-context-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.CookiesAsync</x-search>

If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs are returned.

**Usage**

```csharp
await BrowserContext.CookiesAsync(urls);
```

**Arguments**
- `urls` [string]?|[IEnumerable]?<[string]> *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-option-urls"/><a href="#browser-context-cookies-option-urls" class="list-anchor">#</a>
  
  Optional list of URLs.

**Returns**
- [IEnumerable]<`Cookie`><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-return"/><a href="#browser-context-cookies-return" class="list-anchor">#</a>
  - `name` [string]
    
    
  - `value` [string]
    
    
  - `domain` [string]
    
    
  - `path` [string]
    
    
  - `expires` [float]
    
    Unix time in seconds.
  - `httpOnly` [bool]
    
    
  - `secure` [bool]
    
    
  - `sameSite` `enum SameSiteAttribute { Strict, Lax, None }`
    
    
---

### ExposeBindingAsync {#browser-context-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.ExposeBindingAsync</x-search>

The method adds a function called `name` on the `window` object of every frame in every page in the context. When called, the function executes `callback` and returns a [Promise] which resolves to the return value of `callback`. If the `callback` returns a [Promise], it will be awaited.

The first argument of the `callback` function contains information about the caller: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

See [Page.ExposeBindingAsync()](/api/class-page.mdx#page-expose-binding) for page-only version.

**Usage**

An example of exposing page URL to all frames in all pages in the context:

```csharp
using Microsoft.Playwright;

using var playwright = await Playwright.CreateAsync();
var browser = await playwright.Webkit.LaunchAsync(new() { Headless = false });
var context = await browser.NewContextAsync();

await context.ExposeBindingAsync("pageURL", source => source.Page.Url);
var page = await context.NewPageAsync();
await page.SetContentAsync("<script>\n" +
"  async function onClick() {\n" +
"    document.querySelector('div').textContent = await window.pageURL();\n" +
"  }\n" +
"</script>\n" +
"<button onclick=\"onClick()\">Click me</button>\n" +
"<div></div>");
await page.GetByRole(AriaRole.Button).ClickAsync();
```

An example of passing an element handle:

```csharp
var result = new TaskCompletionSource<string>();
var page = await Context.NewPageAsync();
await Context.ExposeBindingAsync("clicked", async (BindingSource _, IJSHandle t) =>
{
    return result.TrySetResult(await t.AsElement().TextContentAsync());
});

await page.SetContentAsync("<script>\n" +
  "  document.addEventListener('click', event => window.clicked(event.target));\n" +
  "</script>\n" +
  "<div>Click me</div>\n" +
  "<div>Or click me</div>\n");

await page.ClickAsync("div");
// Note: it makes sense to await the result here, because otherwise, the context
//  gets closed and the binding function will throw an exception.
Assert.AreEqual("Click me", await result.Task);
```

**Arguments**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-name"/><a href="#browser-context-expose-binding-option-name" class="list-anchor">#</a>
  
  Name of the function on the window object.
- `callback` [Action]<BindingSource, T, [TResult]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-callback"/><a href="#browser-context-expose-binding-option-callback" class="list-anchor">#</a>
  
  Callback function that will be called in the Playwright's context.
- `options` `BrowserContextExposeBindingOptions?` *(optional)*
  - `Handle` [bool]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-handle"/><a href="#browser-context-expose-binding-option-handle" class="list-anchor">#</a>
    
    Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is supported. When passing by value, multiple arguments are supported.

---

### ExposeFunctionAsync {#browser-context-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.ExposeFunctionAsync</x-search>

The method adds a function called `name` on the `window` object of every frame in every page in the context. When called, the function executes `callback` and returns a [Promise] which resolves to the return value of `callback`.

If the `callback` returns a [Promise], it will be awaited.

See [Page.ExposeFunctionAsync()](/api/class-page.mdx#page-expose-function) for page-only version.

**Usage**

An example of adding a `sha256` function to all pages in the context:

```csharp
using Microsoft.Playwright;
using System;
using System.Security.Cryptography;
using System.Threading.Tasks;

class BrowserContextExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Webkit.LaunchAsync(new() { Headless = false });
        var context = await browser.NewContextAsync();

        await context.ExposeFunctionAsync("sha256", (string input) =>
        {
            return Convert.ToBase64String(
                SHA256.Create().ComputeHash(System.Text.Encoding.UTF8.GetBytes(input)));
        });

        var page = await context.NewPageAsync();
        await page.SetContentAsync("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");

        await page.GetByRole(AriaRole.Button).ClickAsync();
        Console.WriteLine(await page.TextContentAsync("div"));
    }
}
```

**Arguments**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-name"/><a href="#browser-context-expose-function-option-name" class="list-anchor">#</a>
  
  Name of the function on the window object.
- `callback` [Action]<T, [TResult]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-callback"/><a href="#browser-context-expose-function-option-callback" class="list-anchor">#</a>
  
  Callback function that will be called in the Playwright's context.

---

### GrantPermissionsAsync {#browser-context-grant-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.GrantPermissionsAsync</x-search>

Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if specified.

**Usage**

```csharp
await BrowserContext.GrantPermissionsAsync(permissions, options);
```

**Arguments**
- `permissions` [IEnumerable]<[string]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-permissions"/><a href="#browser-context-grant-permissions-option-permissions" class="list-anchor">#</a>
  
  A permission or an array of permissions to grant. Permissions can be one of the following values:
  * `'geolocation'`
  * `'midi'`
  * `'midi-sysex'` (system-exclusive midi)
  * `'notifications'`
  * `'camera'`
  * `'microphone'`
  * `'background-sync'`
  * `'ambient-light-sensor'`
  * `'accelerometer'`
  * `'gyroscope'`
  * `'magnetometer'`
  * `'accessibility-events'`
  * `'clipboard-read'`
  * `'clipboard-write'`
  * `'payment-handler'`
- `options` `BrowserContextGrantPermissionsOptions?` *(optional)*
  - `Origin` [string]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-origin"/><a href="#browser-context-grant-permissions-option-origin" class="list-anchor">#</a>
    
    The [origin] to grant permissions to, e.g. "https://example.com".

---

### NewCDPSessionAsync {#browser-context-new-cdp-session}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>browserContext.NewCDPSessionAsync</x-search>

:::note
CDP sessions are only supported on Chromium-based browsers.
:::

Returns the newly created session.

**Usage**

```csharp
await BrowserContext.NewCDPSessionAsync(page);
```

**Arguments**
- `page` [Page]|[Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-option-page"/><a href="#browser-context-new-cdp-session-option-page" class="list-anchor">#</a>
  
  Target to create new session for. For backwards-compatibility, this parameter is named `page`, but it can be a `Page` or `Frame` type.

**Returns**
- [CDPSession]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-return"/><a href="#browser-context-new-cdp-session-return" class="list-anchor">#</a>

---

### NewPageAsync {#browser-context-new-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.NewPageAsync</x-search>

Creates a new page in the browser context.

**Usage**

```csharp
await BrowserContext.NewPageAsync();
```

**Returns**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-page-return"/><a href="#browser-context-new-page-return" class="list-anchor">#</a>

---

### Pages {#browser-context-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.Pages</x-search>

Returns all open pages in the context.

**Usage**

```csharp
BrowserContext.Pages
```

**Returns**
- [IEnumerable]<[Page]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-pages-return"/><a href="#browser-context-pages-return" class="list-anchor">#</a>

---

### RouteAsync {#browser-context-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.RouteAsync</x-search>

Routing provides the capability to modify network requests that are made by any page in the browser context. Once route is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.

:::note
[BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) will not intercept requests intercepted by Service Worker. See [this](https://github.com/microsoft/playwright/issues/1090) issue. We recommend disabling Service Workers when using request interception by setting `Browser.newContext.serviceWorkers` to `'block'`.
:::

**Usage**

An example of a naive handler that aborts all image requests:

```csharp
var context = await browser.NewContextAsync();
var page = await context.NewPageAsync();
await context.RouteAsync("**/*.{png,jpg,jpeg}", r => r.AbortAsync());
await page.GotoAsync("https://theverge.com");
await browser.CloseAsync();
```

or the same snippet using a regex pattern instead:

```csharp
var context = await browser.NewContextAsync();
var page = await context.NewPageAsync();
await context.RouteAsync(new Regex("(\\.png$)|(\\.jpg$)"), r => r.AbortAsync());
await page.GotoAsync("https://theverge.com");
await browser.CloseAsync();
```

It is possible to examine the request to decide the route action. For example, mocking all requests that contain some post data, and leaving all other requests as is:

```csharp
await page.RouteAsync("/api/**", async r =>
{
    if (r.Request.PostData.Contains("my-string"))
        await r.FulfillAsync(body: "mocked-data");
    else
        await r.ContinueAsync();
});
```

Page routes (set up with [Page.RouteAsync()](/api/class-page.mdx#page-route)) take precedence over browser context routes when request matches both handlers.

To remove a route with its handler you can use [BrowserContext.UnrouteAsync()](/api/class-browsercontext.mdx#browser-context-unroute).

:::note
Enabling routing disables http cache.
:::

**Arguments**
- `url` [string]|[Regex]|[Func]<[string], bool><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-url"/><a href="#browser-context-route-option-url" class="list-anchor">#</a>
  
  A glob pattern, regex pattern or predicate receiving [URL] to match while routing. When a `baseURL` via the context options was provided and the passed URL is a path, it gets merged via the [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor.
- `handler` [Action]<[Route]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-handler"/><a href="#browser-context-route-option-handler" class="list-anchor">#</a>
  
  handler function to route the request.
- `options` `BrowserContextRouteOptions?` *(optional)*
  - `Times` [int]? *(optional)* <font size="2">Added in: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-times"/><a href="#browser-context-route-option-times" class="list-anchor">#</a>
    
    How often a route should be used. By default it will be used every time.

---

### RouteFromHARAsync {#browser-context-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.23</font><x-search>browserContext.RouteFromHARAsync</x-search>

If specified the network requests that are made in the context will be served from the HAR file. Read more about [Replaying from HAR](../mock.mdx#replaying-from-har).

Playwright will not serve requests intercepted by Service Worker from the HAR file. See [this](https://github.com/microsoft/playwright/issues/1090) issue. We recommend disabling Service Workers when using request interception by setting `Browser.newContext.serviceWorkers` to `'block'`.

**Usage**

```csharp
await BrowserContext.RouteFromHARAsync(har, options);
```

**Arguments**
- `har` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-har"/><a href="#browser-context-route-from-har-option-har" class="list-anchor">#</a>
  
  Path to a [HAR](http://www.softwareishard.com/blog/har-12-spec) file with prerecorded network data. If `path` is a relative path, then it is resolved relative to the current working directory.
- `options` `BrowserContextRouteFromHAROptions?` *(optional)*
  - `NotFound` `enum HarNotFound { Abort, Fallback }?` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-not-found"/><a href="#browser-context-route-from-har-option-not-found" class="list-anchor">#</a>
    * If set to 'abort' any request not found in the HAR file will be aborted.
    * If set to 'fallback' falls through to the next route handler in the handler chain.
    
    Defaults to abort.
  - `Update` [bool]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update"/><a href="#browser-context-route-from-har-option-update" class="list-anchor">#</a>
    
    If specified, updates the given HAR with the actual network information instead of serving from file. The file is written to disk when [BrowserContext.CloseAsync()](/api/class-browsercontext.mdx#browser-context-close) is called.
  - `UpdateContent` `enum RouteFromHarUpdateContentPolicy { Embed, Attach }?` *(optional)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-content"/><a href="#browser-context-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Optional setting to control resource content management. If `attach` is specified, resources are persisted as separate files or entries in the ZIP archive. If `embed` is specified, content is stored inline the HAR file.
  - `UpdateMode` `enum HarMode { Full, Minimal }?` *(optional)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-mode"/><a href="#browser-context-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page, cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to `minimal`.
  - `Url|UrlRegex` [string]?|[Regex]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-url-url-regex"/><a href="#browser-context-route-from-har-option-url-url-regex" class="list-anchor">#</a>
    
    A glob pattern, regular expression or predicate to match the request URL. Only requests with URL matching the pattern will be served from the HAR file. If not specified, all requests are served from the HAR file.

---

### RunAndWaitForConsoleMessageAsync {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.RunAndWaitForConsoleMessageAsync</x-search>

Performs action and waits for a [ConsoleMessage] to be logged by in the pages in the context. If predicate is provided, it passes [ConsoleMessage] value into the `predicate` function and waits for `predicate(message)` to return a truthy value. Will throw an error if the page is closed before the [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) event is fired.

**Usage**

```csharp
await BrowserContext.RunAndWaitForConsoleMessageAsync(action, options);
```

**Arguments**
- `action` [Func]<[Task]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-action"/><a href="#browser-context-wait-for-console-message-option-action" class="list-anchor">#</a>
  
  Action that triggers the event.
- `options` `BrowserContextRunAndWaitForConsoleMessageOptions?` *(optional)*
  - `Predicate` [Func]<[ConsoleMessage]?, bool> *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Receives the [ConsoleMessage] object and resolves to truthy value when the waiting should resolve.
  - `Timeout` [float]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Returns**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### WaitForConsoleMessageAsync {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.WaitForConsoleMessageAsync</x-search>

Performs action and waits for a [ConsoleMessage] to be logged by in the pages in the context. If predicate is provided, it passes [ConsoleMessage] value into the `predicate` function and waits for `predicate(message)` to return a truthy value. Will throw an error if the page is closed before the [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) event is fired.

**Usage**

```csharp
await BrowserContext.WaitForConsoleMessageAsync(action, options);
```

**Arguments**
- `options` `BrowserContextRunAndWaitForConsoleMessageOptions?` *(optional)*
  - `Predicate` [Func]<[ConsoleMessage]?, bool> *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Receives the [ConsoleMessage] object and resolves to truthy value when the waiting should resolve.
  - `Timeout` [float]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Returns**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### RunAndWaitForPageAsync {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>browserContext.RunAndWaitForPageAsync</x-search>

Performs action and waits for a new [Page] to be created in the context. If predicate is provided, it passes [Page] value into the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the context closes before new [Page] is created.

**Usage**

```csharp
await BrowserContext.RunAndWaitForPageAsync(action, options);
```

**Arguments**
- `action` [Func]<[Task]> <font size="2">Added in: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-action"/><a href="#browser-context-wait-for-page-option-action" class="list-anchor">#</a>
  
  Action that triggers the event.
- `options` `BrowserContextRunAndWaitForPageOptions?` *(optional)*
  - `Predicate` [Func]<[Page]?, bool> *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
    
    Receives the [Page] object and resolves to truthy value when the waiting should resolve.
  - `Timeout` [float]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
    
    Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Returns**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

### WaitForPageAsync {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>browserContext.WaitForPageAsync</x-search>

Performs action and waits for a new [Page] to be created in the context. If predicate is provided, it passes [Page] value into the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the context closes before new [Page] is created.

**Usage**

```csharp
await BrowserContext.WaitForPageAsync(action, options);
```

**Arguments**
- `options` `BrowserContextRunAndWaitForPageOptions?` *(optional)*
  - `Predicate` [Func]<[Page]?, bool> *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
    
    Receives the [Page] object and resolves to truthy value when the waiting should resolve.
  - `Timeout` [float]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
    
    Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Returns**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

### SetDefaultNavigationTimeout {#browser-context-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.SetDefaultNavigationTimeout</x-search>

This setting will change the default maximum navigation time for the following methods and related shortcuts:
* [Page.GoBackAsync()](/api/class-page.mdx#page-go-back)
* [Page.GoForwardAsync()](/api/class-page.mdx#page-go-forward)
* [Page.GotoAsync()](/api/class-page.mdx#page-goto)
* [Page.ReloadAsync()](/api/class-page.mdx#page-reload)
* [Page.SetContentAsync()](/api/class-page.mdx#page-set-content)
* [Page.RunAndWaitForNavigationAsync()](/api/class-page.mdx#page-wait-for-navigation)

:::note
[Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) and [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) take priority over [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Usage**

```csharp
BrowserContext.SetDefaultNavigationTimeout(timeout);
```

**Arguments**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-navigation-timeout-option-timeout"/><a href="#browser-context-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Maximum navigation time in milliseconds

---

### SetDefaultTimeout {#browser-context-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.SetDefaultTimeout</x-search>

This setting will change the default maximum time for all the methods accepting `timeout` option.

:::note
[Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout), [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) and [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout) take priority over [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
:::

**Usage**

```csharp
BrowserContext.SetDefaultTimeout(timeout);
```

**Arguments**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-timeout-option-timeout"/><a href="#browser-context-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Maximum time in milliseconds

---

### SetExtraHTTPHeadersAsync {#browser-context-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.SetExtraHTTPHeadersAsync</x-search>

The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged with page-specific extra HTTP headers set with [Page.SetExtraHTTPHeadersAsync()](/api/class-page.mdx#page-set-extra-http-headers). If page overrides a particular header, page-specific header value will be used instead of the browser context header value.

:::note
[BrowserContext.SetExtraHTTPHeadersAsync()](/api/class-browsercontext.mdx#browser-context-set-extra-http-headers) does not guarantee the order of headers in the outgoing requests.
:::

**Usage**

```csharp
await BrowserContext.SetExtraHTTPHeadersAsync(headers);
```

**Arguments**
- `headers` [IDictionary]<[string], [string]><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-option-headers"/><a href="#browser-context-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  An object containing additional HTTP headers to be sent with every request. All header values must be strings.

---

### SetGeolocationAsync {#browser-context-set-geolocation}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.SetGeolocationAsync</x-search>

Sets the context's geolocation. Passing `null` or `undefined` emulates position unavailable.

**Usage**

```csharp
await context.SetGeolocationAsync(new Geolocation()
{
    Latitude = 59.95f,
    Longitude = 30.31667f
});
```

:::note
Consider using [BrowserContext.GrantPermissionsAsync()](/api/class-browsercontext.mdx#browser-context-grant-permissions) to grant permissions for the browser context pages to read its geolocation.
:::

**Arguments**
- `geolocation` Geolocation?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-option-geolocation"/><a href="#browser-context-set-geolocation-option-geolocation" class="list-anchor">#</a>
  - `Latitude` [float]
    
    Latitude between -90 and 90.
  - `Longitude` [float]
    
    Longitude between -180 and 180.
  - `Accuracy` [float]? *(optional)*
    
    Non-negative accuracy value. Defaults to `0`.

---

### SetOfflineAsync {#browser-context-set-offline}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.SetOfflineAsync</x-search>

**Usage**

```csharp
await BrowserContext.SetOfflineAsync(offline);
```

**Arguments**
- `offline` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-option-offline"/><a href="#browser-context-set-offline-option-offline" class="list-anchor">#</a>
  
  Whether to emulate network being offline for the browser context.

---

### StorageStateAsync {#browser-context-storage-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.StorageStateAsync</x-search>

Returns storage state for this browser context, contains current cookies and local storage snapshot.

**Usage**

```csharp
await BrowserContext.StorageStateAsync(options);
```

**Arguments**
- `options` `BrowserContextStorageStateOptions?` *(optional)*
  - `Path` [string]? *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-path"/><a href="#browser-context-storage-state-option-path" class="list-anchor">#</a>
    
    The file path to save the storage state to. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, storage state is still returned, but won't be saved to the disk.

**Returns**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-return"/><a href="#browser-context-storage-state-return" class="list-anchor">#</a>

---

### UnrouteAsync {#browser-context-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.UnrouteAsync</x-search>

Removes a route created with [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route). When `handler` is not specified, removes all routes for the `url`.

**Usage**

```csharp
await BrowserContext.UnrouteAsync(url, handler);
```

**Arguments**
- `url` [string]|[Regex]|[Func]<[string], bool><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-url"/><a href="#browser-context-unroute-option-url" class="list-anchor">#</a>
  
  A glob pattern, regex pattern or predicate receiving [URL] used to register a routing with [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route).
- `handler` [Action]<[Route]?> *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-handler"/><a href="#browser-context-unroute-option-handler" class="list-anchor">#</a>
  
  Optional handler function used to register a routing with [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route).

---

## Properties

### APIRequest {#browser-context-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.16</font><x-search>browserContext.APIRequest</x-search>

API testing helper associated with this context. Requests made with this API will use context cookies.

**Usage**

```csharp
BrowserContext.APIRequest
```

**Type**
- [APIRequestContext]

---

### Tracing {#browser-context-tracing}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.Tracing</x-search>

**Usage**

```csharp
BrowserContext.Tracing
```

**Type**
- [Tracing]

---

## Events

### event Close {#browser-context-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.event Close</x-search>

Emitted when Browser context gets closed. This might happen because of one of the following:
* Browser context is closed.
* Browser application is closed or crashed.
* The [Browser.CloseAsync()](/api/class-browser.mdx#browser-close) method was called.

**Usage**

```csharp
BrowserContext.Close += async data => {};
```

**Event data**
- [BrowserContext]

---

### event Console {#browser-context-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.event Console</x-search>

Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.

The arguments passed into `console.log` and the page are available on the [ConsoleMessage] event handler argument.

**Usage**

```csharp
context.Console += async (_, msg) =>
{
    foreach (var arg in msg.Args)
        Console.WriteLine(await arg.JsonValueAsync<object>());
};

await page.EvaluateAsync("console.log('hello', 5, { foo: 'bar' })");
```

**Event data**
- [ConsoleMessage]

---

### event Dialog {#browser-context-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.event Dialog</x-search>

Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Listener **must** either [Dialog.AcceptAsync()](/api/class-dialog.mdx#dialog-accept) or [Dialog.DismissAsync()](/api/class-dialog.mdx#dialog-dismiss) the dialog - otherwise the page will [freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking) waiting for the dialog, and actions like click will never finish.

**Usage**

```csharp
context.Dialog += (_, dialog) => dialog.AcceptAsync();
```

:::note
When no [Page.Dialog](/api/class-page.mdx#page-event-dialog) or [BrowserContext.Dialog](/api/class-browsercontext.mdx#browser-context-event-dialog) listeners are present, all dialogs are automatically dismissed.
:::

**Event data**
- [Dialog]

---

### event Page {#browser-context-event-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.8</font><x-search>browserContext.event Page</x-search>

The event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event will also fire for popup pages. See also [Page.Popup](/api/class-page.mdx#page-event-popup) to receive events about popups relevant to a specific page.

The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a popup with `window.open('http://example.com')`, this event will fire when the network request to "http://example.com" is done and its response has started loading in the popup.

```csharp
var popup = await context.RunAndWaitForPageAsync(async =>
{
    await page.GetByText("open new page").ClickAsync();
});
Console.WriteLine(await popup.EvaluateAsync<string>("location.href"));
```

:::note
Use [Page.WaitForLoadStateAsync()](/api/class-page.mdx#page-wait-for-load-state) to wait until the page gets to a particular state (you should not need it in most cases).
:::

**Usage**

```csharp
BrowserContext.Page += async data => {};
```

**Event data**
- [Page]

---

### event Request {#browser-context-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.event Request</x-search>

Emitted when a request is issued from any pages created through this context. The [request] object is read-only. To only listen for requests from a particular page, use [Page.Request](/api/class-page.mdx#page-event-request).

In order to intercept and mutate requests, see [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) or [Page.RouteAsync()](/api/class-page.mdx#page-route).

**Usage**

```csharp
BrowserContext.Request += async data => {};
```

**Event data**
- [Request]

---

### event RequestFailed {#browser-context-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.event RequestFailed</x-search>

Emitted when a request fails, for example by timing out. To only listen for failed requests from a particular page, use [Page.RequestFailed](/api/class-page.mdx#page-event-request-failed).

:::note
HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request will complete with [BrowserContext.RequestFinished](/api/class-browsercontext.mdx#browser-context-event-request-finished) event and not with [BrowserContext.RequestFailed](/api/class-browsercontext.mdx#browser-context-event-request-failed).
:::

**Usage**

```csharp
BrowserContext.RequestFailed += async data => {};
```

**Event data**
- [Request]

---

### event RequestFinished {#browser-context-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.event RequestFinished</x-search>

Emitted when a request finishes successfully after downloading the response body. For a successful response, the sequence of events is `request`, `response` and `requestfinished`. To listen for successful requests from a particular page, use [Page.RequestFinished](/api/class-page.mdx#page-event-request-finished).

**Usage**

```csharp
BrowserContext.RequestFinished += async data => {};
```

**Event data**
- [Request]

---

### event Response {#browser-context-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.event Response</x-search>

Emitted when [response] status and headers are received for a request. For a successful response, the sequence of events is `request`, `response` and `requestfinished`. To listen for response events from a particular page, use [Page.Response](/api/class-page.mdx#page-event-response).

**Usage**

```csharp
BrowserContext.Response += async data => {};
```

**Event data**
- [Response]

---

### event WebError {#browser-context-event-web-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.38</font><x-search>browserContext.event WebError</x-search>

Emitted when exception is unhandled in any of the pages in this context. To listen for errors from a particular page, use [Page.PageError](/api/class-page.mdx#page-event-page-error) instead.

**Usage**

```csharp
BrowserContext.WebError += async data => {};
```

**Event data**
- [WebError]


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.jammy]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.jammy "Dockerfile.jammy"
