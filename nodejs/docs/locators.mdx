---
id: locators
title: "Locators"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

[Locator]s are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent a way to find element(s) on the page at any moment.

### Quick Guide

These are the recommended built in locators.
- [page.getByRole(role[, options])](/api/class-page.mdx#page-get-by-role) to locate by explicit and implicit accessibility attributes.
- [page.getByText(text[, options])](/api/class-page.mdx#page-get-by-text) to locate by text content.
- [page.getByLabel(text[, options])](/api/class-page.mdx#page-get-by-label) to locate a form control by associated label's text.
- [page.getByPlaceholder(text[, options])](/api/class-page.mdx#page-get-by-placeholder) to locate an input by placeholder.
- [page.getByAltText(text[, options])](/api/class-page.mdx#page-get-by-alt-text) to locate an element, usually image, by its text alternative.
- [page.getByTitle(text[, options])](/api/class-page.mdx#page-get-by-title) to locate an element by its title.
- [page.getByTestId(testId)](/api/class-page.mdx#page-get-by-test-id) to locate an element based on its `data-testid` attribute (other attribute can be configured).

```js
await page.getByLabel('User Name').fill('John');

await page.getByLabel('Password').fill('secret-password');

await page.getByRole('button', { name: 'Sign in' }).click();

await expect(page.getByText('Welcome, John!')).toBeVisible();
```

Every time locator is used for some action, up-to-date DOM element is located in the page. So in the snippet below, underlying DOM element is going to be located twice, prior to every action. This means that if the DOM changes in between the calls due to re-render, the new element corresponding to the locator will be used.

```js
const locator = page.getByText('Submit');
// ...
await locator.hover();
await locator.click();
```

## Strictness

Locators are strict. This means that all operations on locators that imply some target DOM element will throw an exception if more than one element matches given selector. For example, the following call throws if there are several buttons in the DOM:

```js
await page.getByRole('button').click();
```

On the other hand, Playwright understands when you perform a multiple-element operation, so the following call works perfectly fine when locator resolves to multiple elements.

```js
await page.getByRole('button').count();
```

You can explicitly opt-out from strictness check by telling Playwright which element to use when multiple element match, through [locator.first()](/api/class-locator.mdx#locator-first), [locator.last()](/api/class-locator.mdx#locator-last), and [locator.nth(index)](/api/class-locator.mdx#locator-nth). These methods are **not recommended** because when your page changes, Playwright may click on an element you did not intend. Instead, follow best practices below to create a locator that uniquely identifies the target element.

## Locating elements

Playwright comes with multiple built-in ways to create a locator. To make tests resilient, we recommend prioritizing user-facing attributes and explicit contracts, and provide dedicated methods for them, such as [page.getByText(text[, options])](/api/class-page.mdx#page-get-by-text). It is often convenient to use the [code generator](./codegen.mdx) to generate a locator, and then edit it as you'd like.

```js
await page.getByText('Log in').click();
```

If you absolutely must use CSS or XPath locators, you can use [page.locator(selector[, options])](/api/class-page.mdx#page-locator) to create a locator that takes a [selector](./selectors.mdx) describing how to find an element in the page.

Note that all methods that create a locator, such as [page.getByLabel(text[, options])](/api/class-page.mdx#page-get-by-label), are also available on the [Locator] and [FrameLocator] classes, so you can chain them and iteratively narrow down your locator.

```js
const locator = page.frameLocator('#my-frame').getByText('Submit');
await locator.click();
```

### Locate based on accessible attributes

The [page.getByRole(role[, options])](/api/class-page.mdx#page-get-by-role) locator reflects how users and assistive technology perceive the page, for example whether some element is a button or a checkbox. When locating by role, you should usually pass the accessible name as well, so that locator pinpoints the exact element.

```js
await page.getByRole('button', { name: /submit/i }).click();

await page.getByRole('checkbox', { checked: true, name: "Check me" }).check();
```

Role locators follow W3C specifications for [ARIA role](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA attributes](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) and [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).

Note that role locators **do not replace** accessibility audits and conformance tests, but rather give early feedback about the ARIA guidelines.

### Locate by label text

Most form controls usually have dedicated labels that could be conveniently used to interact with the form. In this case, you can locate the control by its associated label using [page.getByLabel(text[, options])](/api/class-page.mdx#page-get-by-label).

For example, consider the following DOM structure.

```html
<label for="password">Password:</label><input type="password" id="password">
```

You can fill the input after locating it by the label text:

```js
await page.getByLabel('Password').fill('secret');
```

### Locate by placeholder text

Inputs may have a placeholder attribute to hint to the user what value should be entered. You can locate such an input using [page.getByPlaceholder(text[, options])](/api/class-page.mdx#page-get-by-placeholder).

For example, consider the following DOM structure.

```html
 <input id="email" name="email" type="email" placeholder="name@example.com">
```

You can fill the input after locating it by the placeholder text:

```js
await page.getByPlaceholder("name@example.com").fill("playwright@microsoft.com");
```

### Locate by text

The easiest way to find an element is to look for the text it contains. You can match by a substring, exact string, or a regular expression when using [page.getByText(text[, options])](/api/class-page.mdx#page-get-by-text).

```js
await page.getByText('Log in').click();
await page.getByText('Log in', { exact: true }).click();
await page.getByText(/log in$/i).click();
```

You can also [filter by text](#filter-by-text) when locating in some other way, for example find a particular item in the list.

```js
await page.getByTestId('product-item').filter({ hasText: 'Playwright Book' }).click();
```

:::note
Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into one, turns line breaks into spaces and ignores leading and trailing whitespace.
:::

### Locate by alt text

All images should have an `alt` attribute that describes the image. You can locate an image based on the text alternative using [page.getByAltText(text[, options])](/api/class-page.mdx#page-get-by-alt-text).

For example, consider the following DOM structure.

```html
<img alt="playwright logo" src="/playwright-logo.png" />
```

You can click on the image after locating it by the text alternative:

```js
await page.getByAltText('playwright logo').click();
```

### Locate by title

Locate an element with a matching title attribute using [page.getByTitle(text[, options])](/api/class-page.mdx#page-get-by-title).

For example, consider the following DOM structure.

```html
<span title='Issues count'>25 issues</span>
```

You can check the issues count after locating it by the title text:

```js
await expect(page.getByTitle('Issues count')).toHaveText('25 issues');
```

### Define explicit contract and use a data-testid attribute

User-facing attributes like text or accessible name can change over time. In this case it is convenient to define explicit test ids and query them with [page.getByTestId(testId)](/api/class-page.mdx#page-get-by-test-id).

```html
<button data-testid="directions">Itin√©raire</button>
```

```js
await page.getByTestId('directions').click();
```

By default, [page.getByTestId(testId)](/api/class-page.mdx#page-get-by-test-id) will locate elements based on the `data-testid` attribute, but you can configure it in your test config or calling [selectors.setTestIdAttribute(attributeName)](/api/class-selectors.mdx#selectors-set-test-id-attribute).

### Locate in a subtree

You can chain methods that create a locator, like [page.getByText(text[, options])](/api/class-page.mdx#page-get-by-text) or [locator.getByRole(role[, options])](/api/class-locator.mdx#locator-get-by-role), to narrow down the search to a particular part of the page.

For example, consider the following DOM structure:

```html
<div data-testid='product-card'>
  <span>Product 1</span>
  <button>Buy</button>
</div>
<div data-testid='product-card'>
  <span>Product 2</span>
  <button>Buy</button>
</div>
```

For example, we can first find a product card that contains text "Product 2", and then click the button in this specific product card.

```js
const product = page.getByTestId('product-card').filter({ hasText: 'Product 2' });

await product.getByText('Buy').click();
```

### Locate by CSS or XPath selector

Playwright supports CSS and XPath selectors, and auto-detects them if you omit `css=` or `xpath=` prefix. Use [page.locator(selector[, options])](/api/class-page.mdx#page-locator) for this:

```js
await page.locator('css=button').click();
await page.locator('xpath=//button').click();

await page.locator('button').click();
await page.locator('//button').click();
```

XPath and CSS selectors can be tied to the DOM structure or implementation. These selectors can break when the DOM structure changes. Long CSS or XPath chains below are an example of a **bad practice** that leads to unstable tests:

```js
await page.locator('#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input').click();

await page.locator('//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input').click();
```

Instead, try to come up with a locator that is close to how user perceives the page or [define an explicit testing contract](#define-explicit-contract-and-use-pagegetbytestidtestid).

### Locate elements that contain other elements

#### Filter by text

Locator can be optionally filtered by text. It will search for a particular string somewhere inside the element, possibly in a descendant element, case-insensitively. You can also pass a regular expression.

```js
await page.getByTestId('product-card').filter({ hasText: 'Product 3' }).click();
await page.getByTestId('product-card').filter({ hasText: /product 3/ }).click();
```

#### Filter by another locator

Locators support an option to only select elements that have a descendant matching another locator.

```js
page.getByRole('section').filter({ has: page.getByTestId('subscribe-button') })
```

Note that inner locator is matched starting from the outer one, not from the document root.

#### Augment an existing locator

You can filter an existing locator by text or another one, using [locator.filter([options])](/api/class-locator.mdx#locator-filter) method, possibly chaining it multiple times.

```js
const rowLocator = page.locator('tr');
// ...
await rowLocator
    .filter({ hasText: 'text in column 1' })
    .filter({ has: page.getByRole('button', { name: 'column 2 button' }) })
    .screenshot();
```

### Locate elements in Shadow DOM

All locators in Playwright **by default** work with elements in Shadow DOM. The exceptions are:
- Locating by XPath does not pierce shadow roots.
- [Closed-mode shadow roots](https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#parameters) are not supported.

Consider the following example with a custom web component:

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

You can locate in the same way as if the shadow root was not present at all.
- Click `<div>Details</div>`

  ```js
  await page.getByText('Details').click();
  ```

- Click `<x-details>`

  ```js
  await page.locator('x-details', { hasText: 'Details' }).click();
  ```

- Ensure that `<x-details>` contains text "Details"

  ```js
  await expect(page.locator('x-details')).toContainText('Details');
  ```

## Lists

You can also use locators to work with the element lists.

```js
// Locate elements, this locator points to a list.
const rows = page.getByRole('listitem');

// Pattern 1: use locator methods to calculate text on the whole list.
const texts = await rows.allTextContents();

// Pattern 2: do something with each element in the list.
const count = await rows.count()
for (let i = 0; i < count; ++i)
  console.log(await rows.nth(i).textContent());

// Pattern 3: resolve locator to elements on page and map them to their text content.
// Note: the code inside evaluateAll runs in page, you can call any DOM apis there.
const texts = await rows.evaluateAll(list => list.map(element => element.textContent));
```

### Picking specific element from a list

If you have a list of identical elements, and the only way to distinguish between them is the order, you can choose a specific element from a list with [locator.first()](/api/class-locator.mdx#locator-first), [locator.last()](/api/class-locator.mdx#locator-last) or [locator.nth(index)](/api/class-locator.mdx#locator-nth).

For example, to click the third item in the list of products:

```js
await page.getByTestId('product-card').nth(3).click();
```

However, use these methods with caution. Often times, the page might change, and locator will point to a completely different element from the one you expected. Instead, try to come up with a unique locator that will pass the [strictness criteria](#strictness).

[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[Android]: /api/class-android.mdx "Android"
[AndroidDevice]: /api/class-androiddevice.mdx "AndroidDevice"
[AndroidInput]: /api/class-androidinput.mdx "AndroidInput"
[AndroidSocket]: /api/class-androidsocket.mdx "AndroidSocket"
[AndroidWebView]: /api/class-androidwebview.mdx "AndroidWebView"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /test-assertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserServer]: /api/class-browserserver.mdx "BrowserServer"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Coverage]: /api/class-coverage.mdx "Coverage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[Electron]: /api/class-electron.mdx "Electron"
[ElectronApplication]: /api/class-electronapplication.mdx "ElectronApplication"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /test-assertions.mdx "LocatorAssertions"
[Logger]: /api/class-logger.mdx "Logger"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /test-assertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /test-assertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[ScreenshotAssertions]: /test-assertions.mdx "ScreenshotAssertions"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[Worker]: /api/class-worker.mdx "Worker"
[Fixtures]: /api/class-fixtures.mdx "Fixtures"
[Test]: /api/class-test.mdx "Test"
[TestConfig]: /api/class-testconfig.mdx "TestConfig"
[TestError]: /api/class-testerror.mdx "TestError"
[TestInfo]: /api/class-testinfo.mdx "TestInfo"
[TestOptions]: /api/class-testoptions.mdx "TestOptions"
[TestProject]: /api/class-testproject.mdx "TestProject"
[WorkerInfo]: /api/class-workerinfo.mdx "WorkerInfo"
[Location]: /api/class-location.mdx "Location"
[Reporter]: /api/class-reporter.mdx "Reporter"
[Suite]: /api/class-suite.mdx "Suite"
[TestCase]: /api/class-testcase.mdx "TestCase"
[TestResult]: /api/class-testresult.mdx "TestResult"
[TestStep]: /api/class-teststep.mdx "TestStep"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"
[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"
[Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer "Buffer"
[ChildProcess]: https://nodejs.org/api/child_process.html "ChildProcess"
[Error]: https://nodejs.org/api/errors.html#errors_class_error "Error"
[EventEmitter]: https://nodejs.org/api/events.html#events_class_eventemitter "EventEmitter"
[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"
[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"
[null]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null "null"
[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"
[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable "Readable"
[RegExp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp "RegExp"
[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "string"
[void]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined "void"
[URL]: https://nodejs.org/api/url.html "URL"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/about "all available image tags"
[Docker Hub]: https://hub.docker.com/_/microsoft-playwright "Docker Hub"
[Dockerfile.focal]: https://github.com/microsoft/playwright/blob/main/utils/docker/Dockerfile.focal "Dockerfile.focal"
